# 동시성 제어방식에 대한 분석 및 보고서


## 동시성 문제

여러개의 스레드가 공유하려는 자원을 사용하려고 했을 때 동시성문제를 발생한다.
과제의 주제처럼 동시에 포인트를 사용하거나 포인트를 충전했을 때가 그렇다.
포인트 사용/충전 은 포인트라는 데이터가 변경된다. 
즉 동시 요청시 쓰기작업에서 데이터의 일관성이 깨질 수 있기 때문에 동시성제어가 필요하다.

우리는 왜 동시성제어가 필요하는 걸까?

- 데이터 일관성 유지
  : 여러 사용자가 동시에 같은 데이터를 읽고 쓰는 경우 데이터가 예상치 못한 상태로 변경될 수 있다. 동시성 제어를 통해 데이터의 일관성을 유지하고 , 데이터의 손실이나 오류를 방지한다.

- 데이터 무결성 보장

  :  데이터베이스 트랜잭션과 같이 여러 작업이 하나의 논리적인 단위로 처리되어야 하는 경우, 동시성 제어를 통해 데이터의 무결성을 보장한다.

- **시스템 성능 향상**
  : 동시성 제어를 통해 여러 사용자의 요청을 효율적으로 처리하여 시스템의 성능을 향상 시킬 수 있다.

- **데드락 방지**
  : 여러 프로세스나 스레드가 서로 상대방의 자원을 기다리면서 더 이상 진행 되지 못하는 상황인 데드락을 방지한다.

---

## 동시성 제어 구현


### synchronized

간단하고 직관적인 동기화 메커니즘으로 사용되고 있다.
성능이 크게 중요하지 않은 경우에 적합하다.

유연성이 부족하다
- 세분화된 제어가 불가능하다
  - synchronized는 블록 단위로만 락을 걸 수 있어서, 더 세밀한 제어가 필요한 경우에는 한계가 있다. 
  - 예를 들어, 조건에 따라 락을 획득하거나 해제하는 등의 동작을 수행하기 어렵다.

### ReentrantLock  (fairness)

- 재진입이 가능하다.
- 공정한 락(ReentrantLock fairness): 공정한 락은 먼저요청한 스레드가 먼저 락을 획득한다. 즉 먼저 줄서서 기다린 사람이 화장실을 이용할 수 있다.

---

## 동시성 테스트 케이스

- ExecutorService: 스레드풀 개수 셋팅.
- CountDownLatch
  - CountDownLatch 는 여러스레드가 특정 작업을 완료할 때 까지 다른스레드가 기다리도록하는 동기화 도구이다. 
  - CountDownLatch 객체를 생성할 때 초기 카운트 카운트값을 설정하고 각 스레드가 작업을 완료하면 카운트를 감소시킨다.
  - `latch.await()`는 카운트값이 0이될 때까지 await() 메소드를 호출한 스레드는 대기한다.



```java
@Test
    @DisplayName("동일 유저에 대한 동시성 테스트")
    public void 동일_유저가_동시에_포인트를_사용과_포인트조회하는_시나리오를_성공한다() throws InterruptedException {
        //given
        // 새로운 유저 데이터 생성 및 저장
        long userId = 3L;
        long 초기충전량 = 1000L;
        userPointRepository.insertOrUpdate(userId, 초기충전량);


        // 스레드 풀 생성 (10개의 스레드)
        ExecutorService executorService = Executors.newFixedThreadPool(10);

        // CountDownLatch를 사용해 10개의 스레드를 동기화
        /**
         * CountDownLatch
         * - 멀티스레드 프로그래밍에서 스레드들이 모든 작업을 마친후 특정한 작업을 할 때
         *      다른 스레드들에서 일련의 작업이 완료될 때까지 대기하도록 Sync를 맞춰주는 기능이다.
         */
        CountDownLatch latch = new CountDownLatch(10);

        for (int i = 0; i < 10; i++) {
            int finalI = i;
            executorService.execute(() -> {
                try {
                    if(finalI % 2 == 0) {
                        pointService.usePoint(userId, 100); // 100 포인트 감소
                    } else {
                        pointService.getUserPointByUserId(userId); // 포인트 조회
                    }
                } finally {
                    latch.countDown(); // 작업 완료 시 카운트 감소
                }
            });
        }

        // when
        latch.await(); // 모든 스레드가 작업 완료할 때까지 대기
        UserPoint updatedUser = userPointRepository.selectById(userId);

        // then
        assertThat(updatedUser.point()).isEqualTo(500); // 남은 포인트가 500이어야 함
    }

```

- ReentrantLock 을 사용하지 않은 경우에는 포인트사용 5번, 포인트조회 5번 의 테스트케이스가 모두 실패했다.
  위의 테스트케이스에서는 (예측값: 500 / 테스트실행결과값: 800)

- ReentrantLock fairness 를 사용하여 먼저 요청한 스레드를 실행하도록 하였다.

---

## 결론

동시성제어는 데이터 변경으로 인한 데이터의 일관성이 깨지는 상황을 대상으로 필요
그래서 쓰기작업 과 관련된 서비스에서는 동시성제어가 필요합니다.

화장실줄을 서서 기다린적이 있을 것이다. 그때 상황을 가정해보자.
만일 동시성제어를 사용하지 않으면, 내가 화장실을 사용하고 있는데 다른사람이 문을 열고 들어오는 경우랑 같다.
컴퓨터에서는 다른 스레드가 개입을 하는거라고 보면된다.

그래서 다른사람이 들어오지 못하게끔, 내가 사용하고 있다는걸 명시해야된다.
실생활에서도 한사람이 화장실 한칸에 들어가서 문을 잠근다. 그게 락이다.

메서드 수준에서는 synchronized 와 ReentrantLock을 사용하여 동시성을 제어한다.

하지만 락은 동시성을 제어할 뿐, 순서를 보장하진 않는다.
뒤에서 너무 급해서 화장실칸을 양보한적이 있을거다.
순서를 보장하려면 자료구조의 큐(Queue)를 활용해야한다.

<br>

동시성 제어는 여러개의 스레드가 동시에 공유자원을 접근할 때 발생할 수 있는 문제를 해결하는 기술이다.
따라서 동시성제어를 하려면 락이 필요하며, 적절한 동시성 메커니즘을 이해하고 사용할 필요가 있다.
급하게 해서 문서의 질이 떨어지지만 시간이 지나도 synchronized, ReentrantLock 의 차이를 깊이 살펴볼 필요가 있다.
